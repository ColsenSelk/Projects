package edu.iastate.cs472.proj1;

import java.io.FileNotFoundException;

/**
 *  
 * @author Colsen Selk
 *
 */

public class EightPuzzle 
{
	/**
	 * This static method solves an 8-puzzle with a given initial state using three heuristics. The 
	 * first two, allowing single moves only, compare the board configuration with the goal configuration 
	 * by the number of mismatched tiles, and by the Manhattan distance, respectively.  The third 
	 * heuristic, designed by yourself, allows double moves and must be also admissible.  The goal 
	 * configuration set for all puzzles is
	 * 
	 * 			1 2 3
	 * 			8   4
	 * 			7 6 5
	 * 
	 * @param s0
	 * @return a string specified in the javadoc below
	 */
	public static String solve8Puzzle(State s0)
	{
		// TODO 
		
		// 1) If there exists no solution, return a message that starts with "No solution 
		//    exists for the following initial state:" and follows with a blank line and 
		//    then what would be the output from a call s0.toString(). See the end of 
		//    Section 6 in the project description for an example. 
		if (!(s0.solvable())) {
			System.out.println("No solution exists for the following initial state:\n");
			System.out.println(s0.toString());
			return null;
		}

		// 2) Otherwise, solve the puzzle with the three heuristics.  The two solutions generated by
		//    the first two heuristics may be different but must have the same length for optimality. 
		
		Heuristic h[] = {Heuristic.TileMismatch, Heuristic.ManhattanDist, Heuristic.DoubleMoveHeuristic }; 
		String [] moves = new String[3]; 
		
		for (int i = 0; i < 3; i++)
		{
			moves[i] = AStar(s0, h[i]); 
		}
		
		// 3) Combine the three solution strings into one that would print out in the 
		//    output format specified in Section 6 of the project description.
		
		
		return moves[0] + "\n\n" + moves[1] + "\n\n" + moves[2]; 
	}

	
	/**
	 * This method implements the A* algorithm to solve the 8-puzzle with an input initial state s0. 
	 * The algorithm implementation is described in Section 3 of the project description. 
	 * 
	 * Precondition: the puzzle is solvable with the initial state s0.
	 * 
	 * @param s0  initial state
	 * @param h   heuristic 
	 * @return    solution string 
	 */
	public static String AStar(State s0, Heuristic h)
	{
		
		// TODO: fix if broken
		
		// Initialize the two lists used by the algorithm. 
		OrderedStateList OPEN = new OrderedStateList(h, true); 
		OrderedStateList CLOSE = new OrderedStateList(h, false);
					
		
		// Implement the algorithm described in Section 3 to solve the puzzle. 
		// Once a goal state s is reached, call solutionPath(s) and return the solution string. 
			
		//s0.heu = h;
		State.heu = h;
		s0.cost();
		OPEN.addState(s0);
		//int iter = 0; // for testing
		while (true) {
			//iter = iter + 1; // for testing
			//if (iter == 3) { // for testing
				//return "end"; // for testing
			//} // for testing
			State currentState = OPEN.remove();
			if (currentState == null) {
				return "Goal State not found";
			}
			if (currentState.isGoalState()) {
				String tmpStr = "broken heuristic)\n\n";
				if (h == Heuristic.TileMismatch) {
					tmpStr = "number of mismatched tiles)";
				} else if (h == Heuristic.ManhattanDist) {
					tmpStr = "the Manhattan distance)";
				} else if (h == Heuristic.DoubleMoveHeuristic) {
					tmpStr = "double moves allowed)";
				}
				return currentState.numMoves + " moves in total (heuristic: " + tmpStr + solutionPath(currentState);
			}
			//currentState.cost();
			if (State.heu == Heuristic.DoubleMoveHeuristic) {
				try {
				OPEN.addState(currentState.successorState(Move.DBL_LEFT));
				} catch (Exception e) {
					
				}
					try {
					OPEN.addState(currentState.successorState(Move.DBL_RIGHT));
					} catch (Exception e) {
					
				}
					try {
					OPEN.addState(currentState.successorState(Move.DBL_UP));
					} catch (Exception e) {
					
				}
					try {
					OPEN.addState(currentState.successorState(Move.DBL_DOWN));
					} catch (Exception e) {
					
				}
			}
			try {
				OPEN.addState(currentState.successorState(Move.LEFT));
			} catch (Exception e) {
				//System.out.println("LEFT FAIL"); // for testing
			}
				try {
				OPEN.addState(currentState.successorState(Move.RIGHT));
				} catch (Exception e) {
					//System.out.println("RIGHT FAIL"); // for testing
				}
				try {
				OPEN.addState(currentState.successorState(Move.UP));
				} catch (Exception e) {
					
				}
				try {
				OPEN.addState(currentState.successorState(Move.DOWN));
				} catch (Exception e) {
					
				}
				
			
			CLOSE.addState(currentState);
		}
		
		//return null; 
						
	}
	
	
	
	/**
	 * From a goal state, follow the predecessor link to trace all the way back to the initial state. 
	 * Meanwhile, generate a string to represent board configurations in the reverse order, with 
	 * the initial configuration appearing first. Between every two consecutive configurations 
	 * is the move that causes their transition. A blank line separates a move and a configuration.  
	 * In the string, the sequence is preceded by the total number of moves and a blank line. 
	 * 
	 * See Section 6 in the projection description for an example. 
	 * 
	 * Call the toString() method of the State class. 
	 * 
	 * @param goal
	 * @return
	 */
	private static String solutionPath(State goal)
	{
		// TODO: fix if broken
		String Str = goal.move.toString() + "\n\n" + goal.toString();
		State predecessorState = goal.predecessor;
		while (true) {
			if (predecessorState.move == null) {
				Str = "\n\n" + predecessorState.toString() + "\n" + Str;
			} else {
				Str = predecessorState.move.toString() + "\n\n" + predecessorState.toString() + "\n" + Str;
			}
			if (predecessorState.predecessor == null) {
				return Str;
			}
			predecessorState = predecessorState.predecessor;
		}
		
		//return Str; 
	}
	
	
	
}
