package edu.iastate.cs472.proj1;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

/**
 *  
 * @author Colsen Selk
 *
 */


/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is 
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and 
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below: 
 * 
 *  1 2 3 
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object 
 * of the State class. 
 */

public class State implements Cloneable, Comparable<State>
{
	public int[][] board; 		// configuration of tiles 
	
	public State previous;    	// previous node on the OPEN/CLOSED list
	public State next; 			// next node on the OPEN/CLOSED list
	public State predecessor; 	// predecessor node on the path from the initial state 
	
	public Move move;           // the move that generated this state from its predecessor
	public int numMoves; 	    // number of moves from the initial state to this state

	public static Heuristic heu; // heuristic used. shared by all the states. 
	
	private int numMismatchedTiles = -1;    // number of mismatched tiles between this state 
	                                        // and the goal state; negative if not computed yet.
	private int ManhattanDistance = -1;     // Manhattan distance between this state and the 
	                                        // goal state; negative if not computed yet. 
	private int numSingleDoubleMoves = -1;  // number of single and double moves with each double 
										    // move counted as one; negative if not computed yet. 

	
	/**
	 * Constructor (for the initial state).  
	 * 
	 * It takes a 2-dimensional array representing an initial board configuration. The empty 
	 * square is represented by the number 0.  
	 * 
	 *     a) Initialize all three links previous, next, and predecessor to null.  
	 *     b) Set move to null and numMoves to zero.
	 * 
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are 
	 * 										not respectively the digits 0, 1, ..., 8. 
	 */
    public State(int[][] board) throws IllegalArgumentException 
    {
    	this.previous = null;
		this.next = null;
		this.predecessor = null;
		this.move = null;
		this.numMoves = 0;
		
		this.board = new int[3][3];
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				this.board[i][j] = board[i][j];
			}
		}
	}
    
    
    /**
     * Constructor (for the initial state) 
     * 
     * It takes a state from an input file that has three rows, each containing three digits 
     * separated by exactly one blank.  Every row starts with a digit. The nine digits are 
     * from 0 to 8 with no duplicates.  
     * 
     * Do the same initializations as for the first constructor. 
     * 
     * @param inputFileName
     * @throws FileNotFoundException
     * @throws IllegalArgumentException  if the file content does not meet the above requirements. 
     */
    public State (String inputFileName) throws FileNotFoundException, IllegalArgumentException
    {
    	Path inputPath = Paths.get(inputFileName);
    	String[] tempStringArr;
		try {
			tempStringArr = Files.readString(inputPath).split("\n", 4);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return;
		}
		//System.out.println(tempStringArr[0] + "\n" + tempStringArr[1] + "\n" + tempStringArr[2]); // for testing
		
		this.board = new int[3][3]; // [row][col]
		
		for (int i = 0; i < 3; i++) {
			if (tempStringArr[i].charAt(0) == ' ') {
				this.board[i][0] = 0;
			} else {
				this.board[i][0] = Character.getNumericValue(tempStringArr[i].charAt(0));
			}
			if (tempStringArr[i].charAt(2) == ' ') {
				this.board[i][1] = 0;
			} else {
				this.board[i][1] = Character.getNumericValue(tempStringArr[i].charAt(2));
			}
			if (tempStringArr[i].charAt(4) == ' ') {
				this.board[i][2] = 0;
			} else {
				this.board[i][2] = Character.getNumericValue(tempStringArr[i].charAt(4));
			}
		}
		
		this.previous = null;
		this.next = null;
		this.predecessor = null;
		this.move = null;
		this.numMoves = 0;
		//System.out.println(this.toString()); // for testing
	}
    
    
    /**
     * Generate the successor state resulting from a given move.  Throw an exception if the move 
     * cannot be executed.  Besides setting the array board[][] properly, you also need to do the 
     * following:
     * 
     *     a) set the predecessor of the successor state to this state;
     *     b) set the private instance variable move of the successor state to the parameter m; 
     *     c) Set the links next and previous to null;  
     *     d) Set the variable numMoves for the successor state to this.numMoves + 1. 
     * 
     * @param m  one of the moves LEFT, RIGHT, UP, DOWN, DBL_LEFT, DBL_RIGHT, DBL_UP, and DBL_DOWN
     * @return null  			if the successor state is this.predecessor
     *         successor state  otherwise 
     * @throws IllegalArgumentException if LEFT when the empty square is in the right column, or  
     *                                  if RIGHT when the empty square is in the left column, or
     *                                  if UP when the empty square is in the bottom row, or 
     *                                  if DOWN when the empty square is in the top row, or
     *                                  if DBL_LEFT when the empty square is not in the left column, or 
     *                                  if DBL_RIGHT when the empty square is not in the right column, or 
     *                                  if DBL_UP when the empty square is not in the top row, or 
     *                                  if DBL_DOWN when the empty square is not in the bottom row. 
     */                                  
    public State successorState(Move m) throws IllegalArgumentException 
    {
    	int[][] newBoard = new int[3][3];
		int emptyRow = -1, emptyCol = -1;
		for (int i = 0; i < 3; i++) { // copy current board (before move) and find empty space
			for (int j = 0; j < 3; j++) {
				newBoard[i][j] = this.board[i][j];
				if (this.board[i][j] == 0) {
					emptyRow = i;
					emptyCol = j;
				}
			}
		}
		if (emptyRow == -1) {
			System.out.println("Empty Space not found\n");
			throw new IllegalArgumentException();
			//return null;
		}
		
		// TODO update to decrease code length
		if (m == Move.LEFT) { // move Left
			//System.out.println("Move Left"); // for testing
			if (board[0][2] == 0 || board[1][2] == 0 || board[2][2] == 0) { // if empty square is in right column
				throw new IllegalArgumentException();
				//return null;
			}
			int tmp = newBoard[emptyRow][emptyCol+1];
			newBoard[emptyRow][emptyCol] = tmp;
			newBoard[emptyRow][emptyCol+1] = 0;
		}
		else if (m == Move.RIGHT) { // move Right
			//System.out.println("Move Right"); // for testing
			if (board[0][0] == 0 || board[1][0] == 0 || board[2][0] == 0) { // if empty square is in left column
				//System.out.println("Fail"); // for testing
				throw new IllegalArgumentException();
				//return null;
			}
			int tmp = newBoard[emptyRow][emptyCol-1];
			newBoard[emptyRow][emptyCol] = tmp;
			newBoard[emptyRow][emptyCol-1] = 0;
		}
		else if (m == Move.UP) { // move Up
			if (board[2][0] == 0 || board[2][1] == 0 || board[2][2] == 0) { // if empty square is in bottom row
				throw new IllegalArgumentException();
				//return null;
			}
			int tmp = newBoard[emptyRow+1][emptyCol];
			newBoard[emptyRow][emptyCol] = tmp;
			newBoard[emptyRow+1][emptyCol] = 0;
		}
		else if (m == Move.DOWN) { // move Down
			if (board[0][0] == 0 || board[0][1] == 0 || board[0][2] == 0) { // if empty square is in top row
				throw new IllegalArgumentException();
				//return null;
			}
			int tmp = newBoard[emptyRow-1][emptyCol];
			newBoard[emptyRow][emptyCol] = tmp;
			newBoard[emptyRow-1][emptyCol] = 0;
		}
		else if (m == Move.DBL_LEFT) { // move Double Left
			if (!(board[0][0] == 0 || board[1][0] == 0 || board[2][0] == 0)) { // if empty square is NOT in the left column
				throw new IllegalArgumentException();
				//return null;
			}
			int tmp1 = newBoard[emptyRow][1];
			int tmp2 = newBoard[emptyRow][2];
			newBoard[emptyRow][0] = tmp1;
			newBoard[emptyRow][1] = tmp2;
			newBoard[emptyRow][2] = 0;
		}
		else if (m == Move.DBL_RIGHT) { // move Double Right
			if (!(board[0][2] == 0 || board[1][2] == 0 || board[2][2] == 0)) { // if empty square is NOT in the right column
				throw new IllegalArgumentException();
				//return null;
			}
			int tmp1 = newBoard[emptyRow][0];
			int tmp2 = newBoard[emptyRow][1];
			newBoard[emptyRow][1] = tmp1;
			newBoard[emptyRow][2] = tmp2;
			newBoard[emptyRow][0] = 0;
		}
		else if (m == Move.DBL_UP) { // move Double Up
			if (!(board[0][0] == 0 || board[0][1] == 0 || board[0][2] == 0)) { // if empty square is NOT in the top row
				throw new IllegalArgumentException();
				//return null;
			}
			int tmp1 = newBoard[1][emptyCol];
			int tmp2 = newBoard[2][emptyCol];
			newBoard[0][emptyCol] = tmp1;
			newBoard[1][emptyCol] = tmp2;
			newBoard[2][emptyCol] = 0;
		}
		else if (m == Move.DBL_DOWN) { // move Double Down
			if (!(board[2][0] == 0 || board[2][1] == 0 || board[2][2] == 0)) { // if empty square is NOT in the bottom row
				throw new IllegalArgumentException();
				//return null;
			}
			int tmp1 = newBoard[0][emptyCol];
			int tmp2 = newBoard[1][emptyCol];
			newBoard[1][emptyCol] = tmp1;
			newBoard[2][emptyCol] = tmp2;
			newBoard[0][emptyCol] = 0;
		}
		//System.out.println("making new State"); // for testing
		State successor = new State(newBoard);
		successor.predecessor = this;
		successor.move = m;
		successor.numMoves = this.numMoves + 1;
		//successor.heu = this.heu;
		successor.cost();
		
		//System.out.print(this.toString()); // for testing
		//System.out.println(successor.toString()); // for testing
		
		if (this.predecessor == null) {
			return successor;
		} else if (successor.board.equals(this.predecessor.board)) {
			return null;
		} else {
			return successor;
		}
		
		
    	//return null; 
    }
    
        
    /**
     * Determines if the board configuration in this state can be rearranged into the goal configuration. 
     * According to the PowerPoint notes that introduce the 8-puzzle, we check if this state has an odd number 
     * of inversions. 
     */
    /**
     * 
     * @return true if the puzzle starting in this state can be rearranged into the goal state.
     */
    public boolean solvable()
    {
    	// goal state has 7 inversions (1, 2, 3, 8, 4, 7, 6, 5)
		// goal state has 15 inversions if you include the empty state and denote it as 0
		
    	// for testing
    	//System.out.println(this.toString());
    	
		int[] boardArr = new int[9];
		int iter = 0;
		for (int i = 0; i < 3; i++) { // turns board into a flat array
			for (int j = 0; j < 3; j++) {
				if (this.board[i][j] == 0) {
					continue;
				}
				boardArr[iter] = this.board[i][j];
				iter = iter + 1;
			}
		}
		
		int numInv = 0;
		for (int i = 0; i < 7; i++) {
			for (int j = i + 1; j < 8; j++) {
				if (boardArr[i] > boardArr[j]) {
					numInv = numInv + 1;
				}
			}
		}
		
		if (numInv % 2 == 1) { // odd number of inversions. when numInv is odd: 7 - numInv = even number, thus possible
			return true;
		}
		 
    	return false; 
    }
    
    
    /**
     * Check if this state is the goal state, namely, if the array board[][] stores the following contents: 
     * 
     * 		1 2 3 
     * 		8 0 4 
     * 		7 6 5 
     * 
     * @return
     */
    public boolean isGoalState()
    {
    	int[][] goalState = {{1, 2, 3}, {8, 0, 4}, {7, 6, 5}};
		if (Arrays.equals(this.board[0], goalState[0]) && Arrays.equals(this.board[1], goalState[1]) && Arrays.equals(this.board[1], goalState[1])) {
			return true;
		}
		
    	return false; 
    }
    
    
    /**
     * Write the board configuration according to the following format:
     * 
     *     a) Output row by row in three lines with no indentations.  
     *     b) Two adjacent tiles in each row have exactly one blank in between. 
     *     c) The empty square is represented by a blank.  
     *     
     * For example, 
     * 
     * 2   3
     * 1 8 4
     * 7 6 5  
     * 
     */
    @Override 
    public String toString()
    {
    	String Str = this.board[0][0] + " " + this.board[0][1] + " " + this.board[0][2] + "\n" +
			this.board[1][0] + " " + this.board[1][1] + " " + this.board[1][2] + "\n" +
			this.board[2][0] + " " + this.board[2][1] + " " + this.board[2][2] + "\n";
		Str = Str.replace("0", " ");
		
		
		return Str;
    }
    
    
    /**
     * Create a clone of this State object by copying over the board[][]. Set the links previous,
     * next, and predecessor to null. 
     * 
     * The method is called by SuccessorState(); 
     */
    @Override
    public Object clone()
    {
    	int[][] newBoard = new int[3][3];
		for (int i = 0; i < 3; i++) { // copy current board
			for (int j = 0; j < 3; j++) {
				newBoard[i][j] = this.board[i][j];
			}
		}
		
		State newState = new State(newBoard);
		newState.previous = null;
		newState.next = null;
		newState.predecessor = null;
		newState.numMoves = this.numMoves;
		//newState.heu = this.heu;
    	return newState; 
    }
  

    /**
     * Compare this state with the argument state.  Two states are equal if their arrays board[][] 
     * have the same content.
     */
    @Override 
    public boolean equals(Object o)
    {
    	if (Arrays.equals(this.board[0], ((State) o).board[0]) && Arrays.equals(this.board[1], ((State) o).board[1]) && Arrays.equals(this.board[2], ((State) o).board[2])) {
			return true;
		}
    	return false; 
    }
        
    
    /**
     * Evaluate the cost of this state as the sum of the number of moves from the initial state and 
     * the estimated number of moves to the goal state using the heuristic stored in the instance 
     * variable heu. 
     * 
     * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
     * If heu == MahattanDist, add up numMoves and the return values of computeMahattanDistance(). 
     * If heu == DoubleMoveHeuristic, add up numMoves and the return value of computeNumSingleDoubleMoves(). 
     * 
     * @return estimated number of moves from the initial state to the goal state via this state.
     * @throws IllegalArgumentException if heuristic is none of TileMismatch, MahattanDist, DoubleMoveHeuristic. 
     */
    public int cost() throws IllegalArgumentException
    {
    	if (State.heu == Heuristic.TileMismatch) {
			return this.numMoves + computeNumMismatchedTiles();
		} else if (State.heu == Heuristic.ManhattanDist) {
			return this.numMoves + computeManhattanDistance();
		} else if (State.heu == Heuristic.DoubleMoveHeuristic) {
			return this.numMoves + computeNumSingleDoubleMoves();
		} else {
			System.out.println("Illegal Heuristic\n");
			throw new IllegalArgumentException();
			//return -1;
		}
		
    	//return 0; 
    }

    
    /**
     * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
     * 
     * @return -1 if c1 < c2 
     *          0 if c1 = c2 
     *          1 if c1 > c2 
     *          
     * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
     */
    @Override
    public int compareTo(State s)
    {
    	if (this.cost() < s.cost()) {
			return -1;
		} else if (this.cost() == s.cost()) {
			return 0;
		} else {
			return 1;
		}
		
		
    	//return 0; 
    }
    

    /**
     * Return the value of the private variable numMismatchedTiles if it is non-negative, and compute its 
     * value otherwise. 
     * 
     * @return the number of mismatched tiles between this state and the goal state. 
     */
	private int computeNumMismatchedTiles()
	{
		
		// TODO 
		if (this.numMismatchedTiles >= 0) {
			return this.numMismatchedTiles;
		}
		
		this.numMismatchedTiles = 0;
		int[][] goalState = {{1, 2, 3}, {8, 0, 4}, {7, 6, 5}};
		for (int i = 0; i < 3; i++) { // compare boards. if a tile is not correct: add 1 to numMismatchedTiles
			for (int j = 0; j < 3; j++) {
				if (this.board[i][j] != goalState[i][j]) {
					this.numMismatchedTiles = this.numMismatchedTiles + 1;
				}
			}
		}
		
		
		return this.numMismatchedTiles; 
	}

	
	/**
	 * Return the value of the private variable ManhattanDistance if it is non-negative, and compute its value 
	 * otherwise.
	 * 
	 * @return the Manhattan distance between this state and the goal state. 
	 */
	private int computeManhattanDistance()
	{
		if (this.ManhattanDistance >= 0) {
			return this.ManhattanDistance;
		}
		
		this.ManhattanDistance = 0;
		int[][] goalState = {{1, 2, 3}, {8, 0, 4}, {7, 6, 5}};
		for (int i = 0; i < 3; i++) { // compare boards. if a tile is not correct: find same tile on other board and compute manhattan distance and add to ManhattanDistance
			for (int j = 0; j < 3; j++) {
				
				if (this.board[i][j] != goalState[i][j]) { // if tiles are mismatched
					for (int k = 0; k < 3; k++) {
						for (int l = 0; l < 3; l++) {
							if (i == k && j == l) {
								continue;
							}
							if (this.board[i][j] == goalState[k][l]) {
								this.ManhattanDistance = this.ManhattanDistance + Math.abs(i - k) + Math.abs(j - l);
								break;
							}
						}
					}
				}
				
			}
		}
		
		
		return this.ManhattanDistance; 
	}
	
	
	/**
	 * Return the value of the private variable numSingleDoubleMoves if it is non-negative, and compute its value 
	 * otherwise. 
	 * 
	 * @return the value of the private variable numSingleDoubleMoves that bounds from below the number of moves, 
	 *         single or double, which will take this state to the goal state.
	 */
	private int computeNumSingleDoubleMoves()
	{
		if (this.numSingleDoubleMoves >= 0) {
			return this.numSingleDoubleMoves;
		}
		
		this.numSingleDoubleMoves = 0;
		int[][] goalState = {{1, 2, 3}, {8, 0, 4}, {7, 6, 5}};
		for (int i = 0; i < 3; i++) { // compare boards. if a tile is not correct: find same tile on other board and compute manhattan distance (where up-down and left-right values if 2 become 1) and add to numSingleDoubleMoves
			for (int j = 0; j < 3; j++) {
				
				if (this.board[i][j] != goalState[i][j]) { // if tiles are mismatched
					for (int k = 0; k < 3; k++) {
						for (int l = 0; l < 3; l++) {
							if (i == k && j == l) {
								continue;
							}
							if (this.board[i][j] == goalState[k][l]) {
								int tmp = Math.abs(i - k);
								if (tmp == 2) {
									tmp = 2;
									if (this.move == Move.DBL_DOWN || this.move == Move.DBL_UP || this.move == Move.DBL_RIGHT || this.move == Move.DBL_LEFT) {
										tmp = tmp - 1; // if the move is a double it requires one less move
									}
								}
								if (Math.abs(j - l) == 2) {
									tmp = tmp + 2;
									if (this.move == Move.DBL_DOWN || this.move == Move.DBL_UP || this.move == Move.DBL_RIGHT || this.move == Move.DBL_LEFT) {
										tmp = tmp - 1; // if the move is a double it requires one less move
									}
								} else {
									tmp = tmp + Math.abs(j - l);
								}
								
								
								
								this.numSingleDoubleMoves = this.numSingleDoubleMoves + tmp;
								break;
							}
						}
					}
				}
				
			}
		}
		
		return this.numSingleDoubleMoves; 
	}
}
